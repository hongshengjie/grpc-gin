package ginweb

import (
	"strings"

	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	"github.com/golang/protobuf/protoc-gen-go/generator"
)

func init() {
	generator.RegisterPlugin(new(ginweb))
}

const (
	contextPkg = "context"
	ginPkg     = "github.com/gin-gonic/gin"
	httpPkg    = "net/http"
	jsonpbPkg  = "github.com/golang/protobuf/jsonpb"
)

type ginweb struct {
	gen *generator.Generator
}

// Name identifies the plugin.
func (g *ginweb) Name() string {
	return "gin"
}

// Init is called once after data structures are built but before
// code generation begins.
func (g *ginweb) Init(gg *generator.Generator) {
	g.gen = gg

}

// Generate produces the code generated by the plugin for this file,
// except for the imports, by calling the generator's methods P, In, and Out.
func (g *ginweb) Generate(file *generator.FileDescriptor) {
	if len(file.FileDescriptorProto.Service) == 0 {
		return
	}
	g.gen.AddImport(contextPkg)
	g.gen.AddImport(httpPkg)
	g.gen.AddImport(jsonpbPkg)
	g.gen.AddImport(ginPkg)

	for i, service := range file.FileDescriptorProto.Service {
		g.generateHander(file, service, i)
	}

}

// GenerateImports produces the import declarations for this file.
// It is called after Generate.
func (g *ginweb) GenerateImports(file *generator.FileDescriptor) {

}

func (g *ginweb) objectNamed(name string) generator.Object {
	g.gen.RecordTypeUse(name)
	return g.gen.ObjectNamed(name)
}

// Given a type name defined in a .proto, return its name as we will print it.
func (g *ginweb) typeName(str string) string {
	return g.gen.TypeName(g.objectNamed(str))
}

func (g *ginweb) P(args ...interface{}) { g.gen.P(args...) }

func (g *ginweb) generateHander(file *generator.FileDescriptor, service *descriptor.ServiceDescriptorProto, index int) {
	var haveUnary bool
	for _, method := range service.GetMethod() {
		if !method.GetServerStreaming() && !method.GetClientStreaming() {
			haveUnary = true
		}
	}
	if !haveUnary {
		return
	}

	// generate server
	origServName := service.GetName()
	servName := generator.CamelCase(origServName)

	// ginwebServer
	g.P()
	g.P("type ", servName, "GinServer struct {")
	g.P("GServer ", servName, "Server")
	g.P("}")

	//New

	g.P()
	g.P("func New", servName, "GinServer(s ", servName, "Server) *", servName, "GinServer {")
	g.P("web:= &", servName, "GinServer{")
	g.P("GServer: s,")
	g.P("}")
	g.P("return web")
	g.P("}")

	//Methods
	for _, m := range service.GetMethod() {
		methodName := generator.CamelCase(m.GetName())
		inType := g.typeName(m.GetInputType())

		g.P("func (s *", servName, "GinServer) ", methodName, "(c *gin.Context) {")
		g.P("var in ", inType)
		g.P(`if err := jsonpb.Unmarshal(c.Request.Body, &in);err!=nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
			return
		}`)
		g.P("if resp, err := s.GServer.", methodName, "(c, &in);err !=nil{")
		g.P(`c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		} else {
			c.JSON(http.StatusOK, resp)
		}`)
		g.P("}")
	}

	//ServeHTTP
	lowerSerName := strings.ToLower(servName)
	g.P("func (s *", servName, "GinServer) Register", servName, "Hander(e *gin.Engine) {")
	g.P(lowerSerName, `:= e.Group("/`, file.GetPackage(), ".", servName, `")`)
	g.P("{")
	for _, m := range service.GetMethod() {
		methodName := generator.CamelCase(m.GetName())
		g.P(lowerSerName, `.POST("/`, methodName, `", s.`, methodName, ")")
	}
	g.P("}")
	g.P("}")

}
